###### oop

- 通过对象和类来组织代码，主要有是个概念：封装，集成，多态和抽象
- 封装：把相关的数据和方法在同一个类中，并对外隐藏内部实现，只提供接口给外部使用。
- 继承：一个类通过继承另一个类的属性和方法，可以扩展或重写父类的功能。
- 多态，让一个对象以不同的形式表现，通过接口和集成，不同对象可以实现相同的接口，方便调用时能统一的方式处理多种对象。
- 抽象：提取共性特征形成抽象类或接口，不含具体实现，子类通过需求进行拓展。

###### overload重载和override重写区别

- 重载同名但参数不同如参数类型，数量。
- 重写是子类对父类方法的实现


###### 什么是装箱和拆箱

- 将值类型转换为引用类型，如将值类型赋值给object类型就发生了装箱，会在堆上创建一个新的对象，包含值类型副本
- 引用类型转换回值类型的过程。当你从一个 `object` 类型的变量中提取值类型时，就发生了拆箱。拆箱需要进行类型检查，确保对象的实际类型与目标类型相匹配。如 int num=(int)obj;

###### 什么是虚函数？什么是抽象函数？

- 虚函数是允许在派生类中重写的方法，而抽象函数是没有实现，必须在派生类中实现的方法。虚函数有默认行为，抽象函数没有。


###### array数组和list集合区别

- 数组大小固定，声明后不能改变，list是动态的可以随时添加删除元素
- 数组可以是任意类型，一旦定义，其他元素也必须是该类型，list必须用泛型t保证类型一致和安全
- 集合灵活适合频繁变化，数组适合高性能需求

###### 参数，值类型和引用类型

- **参数**可以是值传递或引用传递。

- 值类型存储在栈上，直接包含数据本身，赋值会拷贝副本，不影响本身。
- 引用类型存储在对上，变量存的是对象的引用地址。赋值只是复制引用。

###### 委托

- 委托是一种类型安全的函数指针,将方法作为参数传递或赋值给变量,帮助我们实现事件和回调机制，使代码更加灵活和可重用
- 使用委托时，我们可以定义一个委托类型，然后创建这个类型的实例，指向任何符合该签名的方法

###### 泛型

- 在定义类、接口或方法时，不具体指定数据类型，更加灵活和可重用。
- **避免类型转换错误**：泛型在编译时就检查类型，避免了运行时类型转换错误。

###### 依赖注入

- 用于实现控制反转（IoC）类所依赖的对象（依赖项）从外部传入，而不是在类内部创建

- **松耦合**：减少类之间的依赖，便于替换和修改。

  **更好的维护性**：修改或替换依赖项时不需要改变依赖它的类的代码。

###### 序列化

- 将对象转换为可以存储的格式，可以将对象的状态保存到文件、数据库，或通过网络传输如JSON、XML

###### class和struct异同

- 都是定义对象的

- class是引用类型在堆里，struct是值类型，在栈里
- class实例化用new，struct 可以不用
- class可以集成，struct不可以，但可以实现接口
- class默认是null，struct有默认值，字段会被初始化
- struct处理小数据性更好，但会拷贝，class传递只传递引用。


###### static关键字作用

- 静态成员在所有实例之间共享。
- 属于类而不是类的实例
- 静态类，可以修饰整个类，表示这个类不能被实例化，所有成员都必须是静态的。常用来存放工具方法，比如`Math`类。
- **静态构造函数**：可以用来初始化静态成员，在类被访问之前自动调用，且只会执行一次。

###### abstract class和interface区别

- 定义行为规范并允许多个实现，使用 **接口**
- 共享代码并且希望提供部分实现，使用 **抽象类**。
- 接口定义了一组方法和属性，继承接口必须实现。提供了一种规范，还可以多继承
- 解耦合，降低依赖

###### 何时选择接口，何时选择抽象类

- **选择接口**：
  - 当你希望定义一个完全抽象的契约，不关心具体实现时。
  - 当你需要支持多重继承或想要在不同类之间共享行为时。
- **选择抽象类**：
  - 当你希望共享代码和实现，避免重复时。
  - 当你需要保持一些状态或字段时。
  - 当你希望为所有子类提供一些默认实现时。

######  sealed修饰的类的特点

- 无法被继承，确保类的行为不会被改变或拓展

######   string str = null/“”/string.Empty区别

- null未指向任何对象
- “”长度为零的字符串
- Empty和“”一样，增强可读性，

######   string和StringBuilder区别，两者性能比较

- 一旦创建，内容不能改动，每次修改都会生成新字符串
- 可以在原有基础上直接修改，不会生成新对象

###### 什么是拓展方法

- 扩展方法是让你在不修改现有类型的情况下，为它添加新方法。你只需要定义一个静态方法，并在第一个参数前加上 `this` 关键字。

###### 常见的数据结构

- 数组，列表，链表(由一系列节点组成，每个节点包含数据和指向下一个节点的引用)，字典，栈(先进后出)，队列(先进先出)，

###### 特性是什么？如何使用？

- 特性（Attributes）是用于给代码元素（如类、方法）添加元数据的方式。你可以用它来提供额外信息，比如标记某个方法为过时。使用时只需在元素前加上方括号，如 `[Obsolete]`。

###### const和readonly区别

- `const` 是编译时常量，不能改变；而 `readonly` 是运行时常量，可以在构造函数中赋值。后者更灵活。

###### 强类型，弱类型，哪种好为什么

- 强类型语言会在编译时检查类型，提供更安全的代码；弱类型语言则更灵活，允许更多类型的混合。哪个更好取决于你的需求，安全性和灵活性之间要权衡。

###### 简述C#成员修饰符

- `public`、`private`、`protected` 和 `internal`，它们控制类成员的访问权限。

######  什么是匿名类，好处

- 匿名类是没有显式定义名称的类，通常用来封装一些数据。好处是简化代码，方便创建只用一次的对象。



###### 什么是WebService?

- WebService 是一种允许不同应用程序通过网络互相通信的服务，通常使用 HTTP 和 XML 进行数据交换。


###### 使用foreach遍历访问的对象的要求

- 使用 `foreach` 遍历的对象必须实现 `IEnumerable` 接口，这样才能进行迭代。常见的集合类如数组和 List 都满足这个要求。

###### 什么是反射

- 在运行时动态地获取类型信息，创建对象，调用方法,或者访问字段和属性。可以理解为我们在代码里操作代码本身。
- 如获取类的类型(如Type对象)
- 查看类的方法，属性，字段等
- 动态调用这些方法，甚至修改字段值

###### ORM的延迟加载和直接加载有什么异同

- 延迟加载是等到实际需要数据时才去加载，能节省资源；直接加载则在查询时立即加载所有数据，适合小数据集。延迟加载更灵活，但可能导致多次查询。

###### 什么是异步编程

- 异步编程是一种处理任务的方法，让你在等待某个操作完成时可以执行其他任务。它能提高应用程序的响应性。

###### 什么是并行编程

- 并行编程是指同时执行多个任务，利用多核处理器提高计算性能。它适合 CPU 密集型的操作。

###### 解释下GC

- GC（垃圾回收）是 .NET 中的自动内存管理机制，负责回收不再使用的对象，释放内存，可以帮助避免内存泄漏。

###### 什么是属性(Property)

- 属性是类的成员，提供对字段的封装。用 `get` 和 `set` 方法定义，允许你控制对字段的访问


###### CTS,CLS,CLR解释

**CTS**（公共类型系统）定义了数据类型的标准和规则；

**CLS**（公共语言规范）是确保不同语言可以互操作的规范；

**CLR**（公共语言运行库）是 .NET 应用的执行环境，负责代码管理和运行。


######  消息队列的理解	

- 消息队列是一种异步通信方式，允许不同应用程序或组件通过发送消息进行交互，提高系统的可扩展性和解耦。


###### 内存分配机制

- 内存分配机制是指如何管理程序运行时的内存，包括分配和释放内存。使用堆和栈来存储不同类型的数据。


###### IEnumerable和IQueryable两个接口的区别？

- `IEnumerable` 是用于集合的迭代，适合内存中的数据；`IQueryable` 适合查询数据库，支持 LINQ 语法树，能延迟执行查询。

###### lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求

- 对象只能被一个线程持有，锁定值类型可能导致复制，无法实现真正的锁定。参数要求是引用类型，最好是私有字段，避免外部访问造成死锁。

###### 如何在C#中创建和启动新线程，有哪些方法可以实现多线程并发？

- ```c#
  //直接创建 Thread 对象，然后调用 Start() 方法
  Thread myThread = new Thread(() => { /* 代码 */ });
  myThread.Start();
  //使用 Task 来创建和管理线程
  Task.Run(() => { /* 代码 */ });
  //ThreadPool：使用线程池，可以重用现有线程
  ThreadPool.QueueUserWorkItem(state => { /* 代码 */ });
  ```

###### 什么是线程安全？如何实现

- 某个操作能够在多个线程中同时执行而不会异常。
- 实现线程安全的方法包括：

- **锁定**（lock）：使用 `lock` 关键字来防止多个线程同时访问共享资源。
- **互斥体**（Mutex）：用于跨进程的线程同步。
- **信号量**（Semaphore）：限制同时访问资源的线程数量。
- **原子操作**：确保对某个数据的操作是不可分割的。

###### async/await关键字用来做什么，和传统的多线程有什么不同？

- `async` 修饰一个方法，表示它是异步的，而 `await` 表示等待一个异步操作完成。使用 `async/await` 不会创建新的线程，而是使用已有线程执行任务，避免了线程创建和销毁的开销

###### 主键外键索引

- **唯一标识**：主键是表中每一行的唯一标识，不能重复或为空。

- **建立关系**：外键是指向另一个表主键的字段，用于连接两个表。

- **加速查询**：索引是提高数据库查询速度的工具，像书的目录。

